#include <iostream>

#include <opencv2/opencv.hpp>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part1();
void part2();

std::string PATH_Ball   = "./images/ball.png";
std::string PATH_Coffee = "./images/coffee.png";


//////////////////////////////////////
// function declarations for task 1 //
//////////////////////////////////////
void  drawSnake(             cv::Mat  img, const std::vector<cv::Point2i>& snake);
void  snakes(          const cv::Mat& img, const cv::Point2i center, const int radius, std::vector<cv::Point2i>& snake);


//////////////////////////////////////
// function declarations for task 2 //
//////////////////////////////////////
void    showGray(          const cv::Mat& img, const std::string title="Image", const int t=0);
void    showContour(       const cv::Mat& img, const cv::Mat& contour,          const int t=0);
void    levelSetContours(  const cv::Mat& img, const cv::Point2f center,        const float radius, cv::Mat& phi);
cv::Mat computeContour(    const cv::Mat& phi, const float level );


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main()
{

    // Uncomment the part of the exercise that you wish to implement.
    // For the final submission all implemented parts should be uncommented.

    part1();
    //part2();

    std::cout <<                                                                                                   std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    END    /////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout <<                                                                                                   std::endl;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part1()
{
    std::cout <<                                                                                                   std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 1    //////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout <<                                                                                                   std::endl;

    cv::Mat                                               ball;
    cv::imread( PATH_Ball  , cv::IMREAD_COLOR).convertTo( ball,   CV_32FC3, (1./255.) );
    cv::Mat                                               coffee;
    cv::imread( PATH_Coffee, cv::IMREAD_COLOR).convertTo( coffee, CV_32FC3, (1./255.) );

    std::vector<cv::Point2i>    snake;
    size_t                      radius;
    cv::Point2i                 center;

    std::cout << "ball image" << std::endl;
    // for snake initialization
    center = cv::Point2i( ball.cols/2, ball.rows/2 );
    radius = std::min(    ball.cols/3, ball.rows/3 );
    //////////////////////////////////////
    snakes( ball, center, radius, snake );
    //////////////////////////////////////

    std::cout << "coffee image" << std::endl;
    // for snake initialization
    center = cv::Point2i( coffee.cols/2, coffee.rows/2 );
    radius = std::min(    coffee.cols/3, coffee.rows/3 );
    ////////////////////////////////////////
    snakes( coffee, center, radius, snake );
    ////////////////////////////////////////

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part2()
{
    std::cout <<                                                                                                   std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 2    //////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout <<                                                                                                   std::endl;

    cv::Mat                                               ball;
    cv::imread( PATH_Ball  , cv::IMREAD_COLOR).convertTo( ball,   CV_32FC3, (1./255.) );
    cv::Mat                                               coffee;
    cv::imread( PATH_Coffee, cv::IMREAD_COLOR).convertTo( coffee, CV_32FC3, (1./255.) );



    cv::Mat                     phi;
    size_t                      radius;
    cv::Point2i                 center;

    std::cout << "ball image" << std::endl;
    center = cv::Point2i( ball.cols/2, ball.rows/2 );
    radius = std::min(    ball.cols/3, ball.rows/3 );
    /////////////////////////////////////////////////////////
    levelSetContours(     ball,    center, radius, phi     );
    /////////////////////////////////////////////////////////

    std::cout << "coffee image" << std::endl;
    center = cv::Point2f( coffee.cols/2.f, coffee.rows/2.f );
    radius =    std::min( coffee.cols/3.f, coffee.rows/3.f );
    /////////////////////////////////////////////////////////
    levelSetContours(     coffee,  center, radius, phi     );
    /////////////////////////////////////////////////////////

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////
// apply the snake algorithm to an image //
///////////////////////////////////////////
void snakes( const cv::Mat&                     img,
             const cv::Point2i                  center,
             const int                          radius,
                   std::vector<cv::Point2i>&    snake )
{
    // initialize snake with a circle
    const int     vvvTOTAL =  radius*CV_PI/7; // defines number of snake vertices // adaptive based on the circumference
    snake.resize( vvvTOTAL );
    float angle = 0;
    for (cv::Point2i& vvv: snake)
    {
        vvv.x = round( center.x + cos(angle)*radius );
        vvv.y = round( center.y + sin(angle)*radius );

        angle += 2*CV_PI/vvvTOTAL;
    }

    std::vector<cv::Point2i>    neighbor;
    neighbor.resize(9);
    int counter = 0;

    neighbor.at(counter).x = 0;
    neighbor.at(counter).y = 0;
    counter++;

    // Fill the neighbormatrix
    for (int m = -1; m<2;m++){
        for (int n= -1;n<2;n++){

            if (m!=0 && n!=0){
                neighbor.at(counter).x = m;
                neighbor.at(counter).y = n;
                counter++;
            }
        }
    }

    // visualization
    cv::Mat     vis;
    img.copyTo( vis );
    drawSnake(  vis, snake);
    ///////////////////////////////////////////////////////////
    std::cout << "Press any key to continue...\n" << std::endl;
    ///////////////////////////////////////////////////////////
    cv::imshow("Snake", vis);
    cv::waitKey();

    int min_position, min_final_position;
    float min_energy, energy, min_final_energy;
    cv::Point2i nextnode, currnode;
    float energyMtx[snake.size()][9];
    int posMtx[snake.size()][9];

    float alpha = 0.001;


    //Calculate the distanceimage
    cv::Mat                           Image_Gray;
    cv::cvtColor(     img, Image_Gray, cv::COLOR_BGR2GRAY );

    cv::Mat                       edgeImg;
    edgeImg.create(Image_Gray.size(),CV_8U);
    cv::Mat                       distanceImg;

    double minVal, maxVal;
    cv::minMaxLoc(Image_Gray, &minVal, &maxVal);
    cv::Mat tmp;
    Image_Gray.convertTo(Image_Gray,CV_8U,255.0/(maxVal-minVal),-minVal*255.0/(maxVal-minVal));

    cv::Canny(Image_Gray,edgeImg,350,450,3,false);

    edgeImg = 255 - edgeImg;


    cv::distanceTransform(edgeImg,distanceImg,CV_DIST_L2,3);

    cv::normalize(distanceImg,distanceImg,0,1,cv::NORM_MINMAX);



    float distanceAvg= 0;
    int c = 0;

    // Calculate the Average distance between the nodes
    for (int i = 1; i<snake.size();i++){
        distanceAvg+= cv::sqrt(((snake.at(i-1).x-snake.at(i).x)*(snake.at(i-1).x-snake.at(i).x))+((snake.at(i-1).y-snake.at(i).y)*(snake.at(i-1).y-snake.at(i).y)));
        c++;
    }
    distanceAvg/=c;


    for (long iterations = 0; iterations<1000;iterations++){

        // Initialization of the first column of the energymatrix
        for (int i=0; i < 9; i++){
            float E_external = distanceImg.at<float>(snake.at(0).x+neighbor.at(i).x,snake.at(0).y+neighbor.at(i).y);;
            energyMtx[0][i] = E_external;
        }

        // start every iteration with a other note
        for (int i = 0; i<snake.size()-1;i++){
            cv::Point2i tmp = snake.at(i);
            snake.at(i) = snake.at(i+1);
            snake.at(i+1) = tmp;

        }





        for (int i = 1; i<snake.size();i++){
            for (int j = 0; j< 9; j++){
                min_energy = INFINITY;
                for (int k = 0; k<9;k++){
                    nextnode.x = snake.at(i).x + neighbor.at(j).x;
                    nextnode.y = snake.at(i).y + neighbor.at(j).y;

                    currnode.x = snake.at(i-1).x + neighbor.at(k).x;
                    currnode.y = snake.at(i-1).y + neighbor.at(k).y;


                    // Calculate the external energy UN and the distnce for the currentnode
                    float E_external = distanceImg.at<float>(nextnode.x,nextnode.y);

                    float distance = alpha * abs(cv::sqrt(((currnode.x-nextnode.x)*(currnode.x-nextnode.x))+((currnode.y-nextnode.y)*(currnode.y-nextnode.y)))-distanceAvg);


                    energy = energyMtx[i-1][k]+E_external +distance;

                    // Find the minimum energy for this node in this position
                    if (energy < min_energy){
                        min_energy = energy ;
                        min_position = k;
                    }
                }

                energyMtx[i][j] = min_energy;
                posMtx[i][j] = min_position;
            }
        }
        min_final_energy = INFINITY;


        // Look in the last column and find there the minumum energy to start with the backwardsstep
        for (int m = 0; m<9;m++){
            if (energyMtx[snake.size()-1][m]< min_final_energy){
                min_final_energy = energyMtx[snake.size()-1][m];
                min_final_position = m;
            }
        }
        int endcounter =0;
        int pos = min_final_position;
        // then go backwards throw the Array to find the best way to change the nodes
        for (int i = snake.size()-1 ; i >=0;i--){
            if (pos == 0){
                endcounter++;

                // if no node is changed in this iteration thats the final result
                if (endcounter == snake.size()-1){
                    drawSnake(  vis, snake);
                    cv::imshow("Final result", vis);
                    cv::waitKey();
                    cv::destroyAllWindows();
                    return;
                }
            }


            snake.at(i).x = snake.at(i).x + neighbor.at(pos).x;
            snake.at(i).y = snake.at(i).y + neighbor.at(pos).y;

            pos = posMtx[i][pos];


        }

        // show the result after every 50 iterations
        if (iterations % 50 == 0){
            std::cout << "iterations " <<iterations<< std::endl;
            drawSnake(  vis, snake);
            cv::imshow("Snake", vis);
            cv::waitKey();
        }
    }

    cv::destroyAllWindows();
}


////////////////////////////////
// draws a snake on the image //
////////////////////////////////
void drawSnake(       cv::Mat                   img,
                const std::vector<cv::Point2i>& snake )
{
    const size_t siz = snake.size();

    for (size_t iii=0; iii<siz; iii++)
        cv::line( img, snake[iii], snake[(iii+1)%siz], cv::Scalar(0,0,1) );

    for (const cv::Point2i& p: snake)
        cv::circle( img, p, 2, cv::Scalar(1,0,0), -1 );
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// runs the level-set geodesic active contours algorithm //
///////////////////////////////////////////////////////////
void levelSetContours( const cv::Mat& img, const cv::Point2f center, const float radius, cv::Mat& phi )
{
    phi.create( img.size(), CV_32FC1 );
    //////////////////////////////
    // signed distance map **phi**
    //////////////////////////////
    // initialize as a cone around the
    // center with phi(x,y)=0 at the radius
    for     (int y=0; y<phi.rows; y++)   {   const  float         disty2 = pow( y-center.y, 2 );
        for (int x=0; x<phi.cols; x++)       phi.at<float>(y,x) = disty2 + pow( x-center.x, 2 );   }
                              cv::sqrt( phi, phi );

    // positive values inside
    phi = (radius - phi);
    cv::Mat temp = computeContour( phi, 0.0f);

    ///////////////////////////////////////////////////////////
    std::cout << "Press any key to continue...\n" << std::endl;
    ///////////////////////////////////////////////////////////
    showGray(    phi, "phi", 1 );
    showContour( img, temp,  0 );
    /////////////////////////////

    // Perform optimization of the initialized level-set function with geodesic active contours as described in the exercise sheet and the slides.
    // Iterate until
    // - the contour does not change between 2 consequitive iterations, or
    // - until a maximum number of iterations is reached

    // At each step visualize the current result
    // using **showGray() and showContour()** as in the example above and when necessary **std::cout**
    // In the end, after the last visualization, use **cv::destroyAllWindows()**

    cv::destroyAllWindows();
}


////////////////////////////
// show a grayscale image //
////////////////////////////
void showGray( const cv::Mat& img, const std::string title, const int t )
{
    CV_Assert( img.channels() == 1 );

    double               minVal,  maxVal;
    cv::minMaxLoc( img, &minVal, &maxVal );

    cv::Mat            temp;
    img.convertTo(     temp, CV_32F, 1./(maxVal-minVal), -minVal/(maxVal-minVal));
    cv::imshow( title, temp);
    cv::waitKey(t);
}


//////////////////////////////////////////////
// compute the pixels where phi(x,y)==level //
//////////////////////////////////////////////
cv::Mat computeContour( const cv::Mat& phi, const float level )
{
    CV_Assert( phi.type() == CV_32FC1 );

    cv::Mat segmented_NORMAL( phi.size(), phi.type() );
    cv::Mat segmented_ERODED( phi.size(), phi.type() );

    cv::threshold( phi, segmented_NORMAL, level, 1.0, cv::THRESH_BINARY );
    cv::erode(          segmented_NORMAL, segmented_ERODED, cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size2i(3,3)) );

    return ( segmented_NORMAL != segmented_ERODED );
}


///////////////////////////
// draw contour on image //
///////////////////////////
void showContour( const cv::Mat& img, const cv::Mat& contour, const int t )
{
    CV_Assert( img.cols == contour.cols   &&
               img.rows == contour.rows   &&
               img.type()     == CV_32FC3 &&
               contour.type() == CV_8UC1  );

    cv::Mat temp( img.size(), img.type() );

    const cv::Vec3f color( 0, 0, 1 ); // BGR

    for     (int y=0; y<img.rows; y++)
        for (int x=0; x<img.cols; x++)
            temp.at<cv::Vec3f>(y,x) = contour.at<uchar>(y,x)!=255 ? img.at<cv::Vec3f>(y,x) : color;

    cv::imshow("contour", temp);
    cv::waitKey(t);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

